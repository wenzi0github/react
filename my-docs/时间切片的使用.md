react源码一直在更新，以下内容以17.0.2为准。

github: [https://github.com/wenzi0github/react/releases/tag/v17.0.2](https://github.com/wenzi0github/react/releases/tag/v17.0.2)。

react中将每个jsx的节点都细化成一个链表节点，然后按照先子节点、然后父节点的顺序进行遍历。

链表的好处就是可以`中断`，若当前节点任务比较繁重，则将主流程控制权交还给浏览器，待浏览器完成更高优先级的任务后，再继续刚才的节点继续执行。

源码位置：[https://github.com/facebook/react/blob/d4d1dc085d1332fdd5025c292adcb5b39811e5b5/packages/scheduler/src/forks/Scheduler.js#L551](https://github.com/facebook/react/blob/d4d1dc085d1332fdd5025c292adcb5b39811e5b5/packages/scheduler/src/forks/Scheduler.js#L551)。

```javascript
let schedulePerformWorkUntilDeadline;
if (typeof localSetImmediate === 'function') {
  // Node.js and old IE.
  // There's a few reasons for why we prefer setImmediate.
  //
  // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.
  // (Even though this is a DOM fork of the Scheduler, you could get here
  // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)
  // https://github.com/facebook/react/issues/20756
  //
  // But also, it runs earlier which is the semantic we want.
  // If other browsers ever implement it, it's better to use it.
  // Although both of these would be inferior to native scheduling.
  schedulePerformWorkUntilDeadline = () => {
    localSetImmediate(performWorkUntilDeadline);
  };
} else if (typeof MessageChannel !== 'undefined') {
  // DOM and Worker environments.
  // We prefer MessageChannel because of the 4ms setTimeout clamping.
  const channel = new MessageChannel();
  const port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;
  schedulePerformWorkUntilDeadline = () => {
    port.postMessage(null);
  };
} else {
  // We should only fallback here in non-browser environments.
  schedulePerformWorkUntilDeadline = () => {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
}
```

优先使用setImmediate，否则使用MessageChannel，最后兜底使用setTimeout。

为什么不使用requestIdleCallabck或者requestAnimationFrame呢？这主要是受限于浏览器刷新率的影响，下一个任务并不能快速地执行。

这里的issue有解释：[https://github.com/facebook/react/issues/21662#issuecomment-859671432](https://github.com/facebook/react/issues/21662#issuecomment-859671432)。大概意思是：requestIdleCallback启动有延迟，于是就用MessageChannel来模拟实现了。

而关于setTimeout或者setInterval，若存在多层嵌套时，第1次使用时，大概会在1ms左右启动，但后续的回调则会回升到5ms左右。

参考文章：

* https://juejin.cn/post/6844903975112671239
* https://github.com/facebook/react/blob/d4d1dc085d1332fdd5025c292adcb5b39811e5b5/packages/scheduler/src/forks/Scheduler.js#L551
* https://github.com/facebook/react/issues/21662#issuecomment-859671432
